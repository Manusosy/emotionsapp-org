import { useEffect, useState, useContext, useCallback } from "react";
import { useNavigate, useLocation } from "react-router-dom";
import DashboardLayout from "../components/DashboardLayout";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { 
  Calendar as CalendarIcon, 
  Clock, 
  Video, 
  Phone, 
  MessageSquare, 
  Filter, 
  MapPin,
  ChevronLeft,
  ChevronRight,
  Mail,
  Phone as PhoneIcon,
  CalendarClock,
  Star,
  Calendar,
  Info,
  FilterIcon,
  X,
  CalendarPlus,
  RefreshCw,
  CheckCircle2,
  GraduationCap,
  UserRound,
  CalendarRange,
  ChevronDown,
  FileText,
  Download,
  FileOutput,
  Printer,
  FileDown,
  FileText as FilePdf
} from "lucide-react";
import { AuthContext } from "@/contexts/authContext";
import { Skeleton } from "@/components/ui/skeleton";
import { toast } from "sonner";
import { format, addDays, parse, startOfWeek, endOfWeek, startOfMonth, endOfMonth, subDays, subMonths } from "date-fns";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Database } from '../../../types/database.types';
import { supabase } from "@/lib/supabase";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { cn } from "@/lib/utils";
import { Spinner } from "@/components/ui/spinner";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Textarea } from "@/components/ui/textarea";
import FallbackAvatar from "@/components/ui/fallback-avatar";
import { appointmentService } from "@/services";
import { ChatButton } from "@/components/messaging/ChatButton";
import { useAuth } from "@/contexts/authContext";
import BookingButton from "@/features/booking/components/BookingButton";
import { ReviewModal } from "@/features/reviews/components/ReviewModal";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";

// Define the Appointment type
interface Appointment {
  id: string;
  date: string;
  time: string;
  type: 'video' | 'audio' | 'chat';
  status: 'pending' | 'scheduled' | 'confirmed' | 'cancelled' | 'completed';
  concerns?: string;
  notes?: string;
  duration?: string;
  isReviewed?: boolean;
}

// Define the MoodMentorProfile type
interface MoodMentorProfile {
  id: string;
  name: string;
  specialty: string;
  avatar: string;
  rating?: number;
  reviews?: number;
  available?: boolean;
  nextAvailable?: string;
  email?: string;
  phone?: string;
  bio?: string;
  education?: string;
}

// Define the AppointmentWithMentor type
interface AppointmentWithMentor extends Appointment {
  mentor?: {
    id: string;
    name: string;
    specialty: string;
    avatar: string;
    email: string;
    phone: string;
  }
}

// Define the DateFilter type
interface DateFilter {
  label: string;
  startDate: Date;
  endDate: Date;
}

export default function AppointmentsPage() {
  const navigate = useNavigate();
  const { user } = useAuth();
  const [appointments, setAppointments] = useState<AppointmentWithMentor[]>([]);
  const [moodMentors, setMoodMentors] = useState<MoodMentorProfile[]>([]);
  const [loading, setLoading] = useState(true);
  const [activeTab, setActiveTab] = useState("upcoming");
  
  // Debug mode counter
  const [titleClicks, setTitleClicks] = useState(0);
  const handleTitleClick = () => {
    const newCount = titleClicks + 1;
    setTitleClicks(newCount);
    
    // Enable debug mode after 5 clicks
    if (newCount === 5) {
      localStorage.setItem('debug_mode', 'true');
      toast.success('Debug mode enabled');
    }
  };
  
  // Update page title
  useEffect(() => {
    document.title = "My Appointments | Emotions Health";
  }, []);

  // Current date
  const today = new Date();
  const [startDate, setStartDate] = useState<Date>(today);
  const [endDate, setEndDate] = useState<Date>(addDays(today, 6));
  const [dateFilterOpen, setDateFilterOpen] = useState(false);

  // Appointment counts
  const [counts, setCounts] = useState({
    upcoming: 0,
    cancelled: 0,
    completed: 0
  });
  
  // Date filter options
  const dateFilters: DateFilter[] = [
    {
      label: "Today",
      startDate: today,
      endDate: today
    },
    {
      label: "Yesterday",
      startDate: subDays(today, 1),
      endDate: subDays(today, 1)
    },
    {
      label: "Last 7 Days",
      startDate: subDays(today, 7),
      endDate: today
    },
    {
      label: "Last 30 Days",
      startDate: subDays(today, 30),
      endDate: today
    },
    {
      label: "This Month",
      startDate: startOfMonth(today),
      endDate: endOfMonth(today)
    },
    {
      label: "Last Month",
      startDate: startOfMonth(subMonths(today, 1)),
      endDate: endOfMonth(subMonths(today, 1))
    }
  ];

  const [cancelAppointmentId, setCancelAppointmentId] = useState<string | null>(null);
  const [cancellationReason, setCancellationReason] = useState<string>('');
  const [cancelingAppointment, setCancelingAppointment] = useState<boolean>(false);

  const [loadingMoodMentors, setLoadingMoodMentors] = useState(false);

  const [isReviewModalOpen, setIsReviewModalOpen] = useState(false);
  const [selectedAppointmentForReview, setSelectedAppointmentForReview] = useState<{
    id: string;
    mentorId: string;
    mentorName: string;
  } | null>(null);

  useEffect(() => {
    fetchAppointments();
    fetchMoodMentors();
  }, [user?.id, activeTab, startDate, endDate]);

  const fetchAppointments = async () => {
    try {
      // Get the current user from auth context
      const { data: { user: currentUser } } = await supabase.auth.getUser();
      
      if (!currentUser || !currentUser.id) {
        console.log("No authenticated user found");
        toast.error("User authentication required");
        setLoading(false);
        return;
      }
      
      setLoading(true);
      console.log(`Fetching appointments for user ${currentUser.id}, tab: ${activeTab}`);
      
      // Get current date in YYYY-MM-DD format
      const today = new Date();
      const todayFormatted = format(today, 'yyyy-MM-dd');
      
      // Determine status filter based on active tab
      let statusFilter: string | undefined;
      if (activeTab === 'upcoming') {
        statusFilter = 'pending,scheduled';
      } else if (activeTab === 'cancelled') {
        statusFilter = 'cancelled';
      } else if (activeTab === 'completed') {
        statusFilter = 'completed';
      }
      
      // Fetch appointments from the database
      const { data: appointmentsData, error } = await supabase
        .from('patient_appointments_view')
        .select('*')
        .eq('patient_id', currentUser.id)
        .in('status', statusFilter ? statusFilter.split(',') : []);
      
      if (error) {
        console.error("Error fetching appointments:", error);
        toast.error("Failed to load appointments: " + error.message);
        setLoading(false);
        return;
      }
      
      // If no data but no error, it means there are no appointments yet
      if (!appointmentsData || appointmentsData.length === 0) {
        console.log("No appointments found for this patient");
        setAppointments([]);
        setCounts({
          upcoming: 0,
          cancelled: 0,
          completed: 0
        });
        setLoading(false);
        return;
      }
      
      console.log("Appointments data:", appointmentsData);
      
      // Get appointments that have been reviewed
      const { data: reviewedAppointments, error: reviewError } = await supabase
        .from('mentor_reviews')
        .select('appointment_id')
        .eq('patient_id', currentUser.id);
        
      if (reviewError) {
        console.error("Error fetching reviewed appointments:", reviewError);
      }
      
      // Create a Set of reviewed appointment IDs for fast lookup
      const reviewedAppointmentIds = new Set(
        (reviewedAppointments || []).map((review: any) => review.appointment_id)
      );
      
      // Map the appointments to the expected format
      const formattedAppointments = appointmentsData.map(appt => ({
        id: appt.id,
        date: appt.date,
        time: appt.start_time,
        type: appt.meeting_type as 'video' | 'audio' | 'chat',
        status: appt.status as 'pending' | 'confirmed' | 'cancelled' | 'completed',
        concerns: appt.description,
        notes: appt.notes,
        duration: '1 hour',
        isReviewed: reviewedAppointmentIds.has(appt.id),
        mentor: {
          id: appt.mentor_id, // This is the auth.users ID
          name: appt.mentor_name || 'Unknown Mentor',
          specialty: appt.mentor_specialty || 'Specialist',
          avatar: appt.mentor_avatar_url || '',
          email: '',
          phone: ''
        }
      }));
      
      // Sort appointments by date and time
      formattedAppointments.sort((a, b) => {
        const dateA = new Date(`${a.date}T${a.time}`);
        const dateB = new Date(`${b.date}T${b.time}`);
        return dateB.getTime() - dateA.getTime();
      });
      
      console.log("Formatted appointments:", formattedAppointments);
      
      // Update appointments state
      setAppointments(formattedAppointments);
      
      // Update counts - count all appointments regardless of current filter
      const allAppointments = await supabase
        .from('patient_appointments_view')
        .select('id, status')
        .eq('patient_id', currentUser.id);
        
      if (!allAppointments.error && allAppointments.data) {
        const upcomingCount = allAppointments.data.filter(a => 
          a.status === 'pending' || a.status === 'scheduled').length;
        const cancelledCount = allAppointments.data.filter(a => 
          a.status === 'cancelled').length;
        const completedCount = allAppointments.data.filter(a => 
          a.status === 'completed').length;
        
        setCounts({
          upcoming: upcomingCount,
          cancelled: cancelledCount,
          completed: completedCount
        });
      } else {
        // Fallback to counting only filtered appointments
        const upcomingCount = appointmentsData.filter(a => a.status === 'pending' || a.status === 'scheduled').length;
        const cancelledCount = appointmentsData.filter(a => a.status === 'cancelled').length;
        const completedCount = appointmentsData.filter(a => a.status === 'completed').length;
        
        setCounts({
          upcoming: upcomingCount,
          cancelled: cancelledCount,
          completed: completedCount
        });
      }
      
      setLoading(false);
    } catch (error: any) {
      console.error("Error in fetchAppointments:", error);
      toast.error("An error occurred while loading appointments: " + (error.message || "Unknown error"));
      setLoading(false);
    }
  };

  const fetchMoodMentors = async () => {
    try {
      setLoadingMoodMentors(true);
      
      // Use mood mentor service to get available mentors
      const { data: mentorsData, error } = await supabase
        .from('mood_mentor_profiles')
        .select('*')
        .eq('availability_status', 'available')
        .limit(5);
      
      if (error) {
        console.error("Error fetching mood mentors:", error);
        setMoodMentors([]);
        return;
      }
      
      if (mentorsData && mentorsData.length > 0) {
        const mappedMentors: MoodMentorProfile[] = mentorsData.map(mentor => ({
          id: mentor.id,
          name: mentor.full_name || 'Mood Mentor',
          specialty: mentor.specialty || 'Mental Health Support',
          avatar: mentor.avatar_url || '/default-avatar.png',
          rating: mentor.rating || 4.5,
          reviews: mentor.review_count || 0,
          available: mentor.availability_status === 'available',
          email: mentor.email || '',
          phone: mentor.phone_number || '',
          bio: mentor.bio || '',
          education: typeof mentor.education === 'string' ? mentor.education : 
            (mentor.education && mentor.education[0]?.degree) ? 
            `${mentor.education[0].degree} from ${mentor.education[0].institution}` : 
            'Mental Health Professional'
        }));
        
        setMoodMentors(mappedMentors);
      } else {
        // If no data from database, use mock data for development
        const mockMentors: MoodMentorProfile[] = [
          {
            id: 'mock-1',
            name: 'Dr. Sarah Johnson',
            specialty: 'Anxiety & Depression',
            avatar: 'https://randomuser.me/api/portraits/women/32.jpg',
            rating: 4.9,
            reviews: 124,
            available: true,
            nextAvailable: 'Today',
            bio: 'Specialized in cognitive behavioral therapy with 10+ years of experience helping patients overcome anxiety and depression.'
          },
          {
            id: 'mock-2',
            name: 'Dr. Michael Chen',
            specialty: 'Stress Management',
            avatar: 'https://randomuser.me/api/portraits/men/45.jpg',
            rating: 4.7,
            reviews: 98,
            available: true,
            nextAvailable: 'Tomorrow',
            bio: 'Expert in mindfulness techniques and stress reduction strategies for professionals and students.'
          },
          {
            id: 'mock-3',
            name: 'Emma Rodriguez',
            specialty: 'Trauma Recovery',
            avatar: 'https://randomuser.me/api/portraits/women/65.jpg',
            rating: 4.8,
            reviews: 87,
            available: true,
            nextAvailable: 'Thursday',
            bio: 'Specialized in trauma-informed care and EMDR therapy to help patients process difficult experiences.'
          }
        ];
        
        console.log("Using mock mood mentors data");
        setMoodMentors(mockMentors);
      }
    } catch (error) {
      console.error("Error fetching mood mentors:", error);
      setMoodMentors([]);
    } finally {
      setLoadingMoodMentors(false);
    }
  };

  const getAppointmentIdCode = (id: string) => {
    // Format the appointment ID to be more user-friendly
    return `#Apt${id.slice(-5)}`;
  };

  const handleApplyDateFilter = (filter: DateFilter) => {
    setStartDate(filter.startDate);
    setEndDate(filter.endDate);
    setDateFilterOpen(false);
  };

  const handleCustomDateRange = () => {
    // This would open a date range picker
    toast.info("Custom date range picker will be implemented soon");
    setDateFilterOpen(false);
  };

  const handleBookWithMentor = (mentorId: string) => {
    navigate(`/booking?mentorId=${mentorId}`);
  };

  const handleViewMentorProfile = (mentorId: string) => {
    const mentor = moodMentors.find(a => a.id === mentorId);
    if (mentor) {
      const nameSlug = mentor.name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
      navigate(`/mood-mentor/${nameSlug}?id=${mentorId}`);
    } else {
      navigate(`/mood-mentor?id=${mentorId}`);
    }
  };

  const handleCancelAppointment = async (appointmentId: string) => {
    try {
      if (!user) {
        toast.error("You must be logged in to cancel appointments");
        return;
      }
      
      setCancelingAppointment(true);
      toast.loading("Cancelling appointment...");
      
      // Use the appointment service to cancel the appointment
      const result = await appointmentService.cancelAppointment(appointmentId, cancellationReason);
      
      if (result.error) {
        console.error("Error cancelling appointment:", result.error);
        toast.dismiss();
        toast.error("Failed to cancel appointment: " + result.error);
        return;
      }

      toast.dismiss();
      toast.success("Appointment cancelled successfully");
      fetchAppointments(); // Refresh appointments after cancellation
    } catch (error) {
      console.error("Error cancelling appointment:", error);
      toast.dismiss();
      toast.error("An error occurred while cancelling the appointment");
    } finally {
      setCancelAppointmentId(null);
      setCancellationReason(''); // Reset the reason
      setCancelingAppointment(false);
    }
  };

  const handleStartChat = async (appointmentId: string) => {
    try {
      const { data: conversationId, error } = await appointmentService.startAppointmentChat(appointmentId);
      
      if (error) {
        // Special handling for database table not existing yet
        if (error.includes('relation') && error.includes('does not exist')) {
          toast.info('Chat system is being set up. Please try again in a moment.');
        } else {
          toast.error('Failed to start chat session: ' + error);
        }
        return;
      }
      
      if (conversationId) {
        navigate(`/chat/${conversationId}`);
      } else {
        toast.error('Could not create a chat session');
      }
    } catch (err) {
      console.error('Error starting chat:', err);
      toast.error('An error occurred while starting the chat');
    }
  };

  // Function to check if a patient can join a session
  const canJoinSession = (appointment: any) => {
    // Patient can join if the appointment is scheduled (mentor has started it)
    // or if it is in progress
    return appointment.status.toLowerCase() === 'scheduled' || 
           appointment.status.toLowerCase() === 'in progress';
  };

  // Function to handle joining a video session
  const handleJoinSession = async (appointment: any) => {
    if (!user) {
      toast.error("You must be logged in to join sessions");
      return;
    }

    if (!canJoinSession(appointment)) {
      toast.info("Please wait for your mentor to start the session.");
      return;
    }

    try {
      // Navigate to the dedicated call page
      navigate(`/patient-dashboard/appointment/${appointment.id}/call`);
      toast.success("Joining video call...");
    } catch (error) {
      console.error("Error joining session:", error);
      toast.error("Failed to join session. Please try again.");
    }
  };
  
  // Function to export appointments as PDF
  const exportAppointmentsToPDF = async () => {
    try {
      toast.loading("Generating PDF...");
      
      // Filter only completed appointments
      const completedAppointments = appointments.filter(
        appointment => appointment.status === 'completed'
      );
      
      if (completedAppointments.length === 0) {
        toast.dismiss();
        toast.error("No completed appointments to export");
        return;
      }
      
      // In a real implementation, we would use a library like jsPDF or html2pdf
      // For now, we'll simulate the PDF generation with a timeout
      
      setTimeout(() => {
        toast.dismiss();
        toast.success("PDF generated successfully!");
        
        // Create a fake download link for demonstration
        const element = document.createElement('a');
        element.setAttribute('href', 'data:text/plain;charset=utf-8,');
        element.setAttribute('download', `appointments_history_${format(new Date(), 'yyyy-MM-dd')}.pdf`);
        element.style.display = 'none';
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      }, 2000);
      
    } catch (error) {
      console.error("Error exporting appointments:", error);
      toast.dismiss();
      toast.error("Failed to generate PDF. Please try again.");
    }
  };

  const openReviewModal = async (appointment: AppointmentWithMentor) => {
    if (!appointment.mentor) {
      toast.error('Mentor information is missing');
      return;
    }

    try {
      // Check if the patient can review this appointment
      const { data: canReview, error: checkError } = await supabase
        .rpc('can_patient_review_appointment', { 
          appointment_id: appointment.id,
          patient_uuid: user?.id
        });
      
      if (checkError) {
        console.error("Error checking if can review:", checkError);
        throw new Error("Couldn't verify if you can review this appointment");
      }
      
      if (!canReview) {
        toast.error('You cannot review this appointment. It may already be reviewed or not completed.');
        return;
      }
      
      setSelectedAppointmentForReview({
        id: appointment.id,
        mentorId: appointment.mentor.id,
        mentorName: appointment.mentor.name,
      });
      setIsReviewModalOpen(true);
    } catch (error: any) {
      console.error("Error in openReviewModal:", error);
      toast.error(error.message || "Failed to open review form");
    }
  };

  return (
    <DashboardLayout>
      <div className="space-y-6">
        {/* Simple header with brand colors */}
        <div className="flex flex-col md:flex-row justify-between items-start md:items-center gap-4 mb-6">
          <div>
            <h1 className="text-2xl font-bold text-gray-800">My Appointments</h1>
            <p className="text-gray-500">Manage and track your therapy sessions</p>
          </div>
          
          <Button 
            onClick={() => navigate('/patient-dashboard/find-mentor')} 
            className="bg-blue-600 hover:bg-blue-700 text-white"
          >
            <CalendarPlus className="mr-2 h-4 w-4" />
            Book New Appointment
          </Button>
        </div>
        
        {/* Simple tab navigation */}
        <div className="border-b">
          <div className="flex space-x-8">
            <button
              onClick={() => setActiveTab("upcoming")}
              className={`pb-2 px-1 font-medium ${
                activeTab === "upcoming"
                  ? "border-b-2 border-blue-600 text-blue-600"
                  : "text-gray-500 hover:text-gray-700"
              }`}
            >
              Upcoming ({counts.upcoming})
            </button>
            <button
              onClick={() => setActiveTab("completed")}
              className={`pb-2 px-1 font-medium ${
                activeTab === "completed"
                  ? "border-b-2 border-blue-600 text-blue-600"
                  : "text-gray-500 hover:text-gray-700"
              }`}
            >
              Completed ({counts.completed})
            </button>
            <button
              onClick={() => setActiveTab("cancelled")}
              className={`pb-2 px-1 font-medium ${
                activeTab === "cancelled"
                  ? "border-b-2 border-blue-600 text-blue-600"
                  : "text-gray-500 hover:text-gray-700"
              }`}
            >
              Cancelled ({counts.cancelled})
            </button>
            
            {/* Export PDF button - only show for completed appointments */}
            {activeTab === "completed" && counts.completed > 0 && (
              <div className="ml-auto">
                <Button 
                  variant="outline" 
                  size="sm"
                  onClick={exportAppointmentsToPDF}
                  className="text-blue-600 border-blue-200 hover:bg-blue-50"
                >
                  <FileDown className="mr-2 h-4 w-4" />
                  Export PDF
                </Button>
              </div>
            )}
          </div>
        </div>

        {/* Appointment List */}
        {loading ? (
          <div className="flex justify-center py-12">
            <Spinner size="lg" className="text-blue-600" />
          </div>
        ) : appointments.filter(appt => 
            activeTab === "upcoming" ? (appt.status === "pending" || appt.status === "scheduled" || appt.status === "confirmed") :
            activeTab === "completed" ? appt.status === "completed" :
            appt.status === "cancelled"
          ).length === 0 ? (
          <div className="text-center py-12 bg-gray-50 rounded-lg border border-gray-100">
            <div className="inline-flex items-center justify-center w-12 h-12 rounded-full bg-blue-100 mb-4">
              {activeTab === "upcoming" && <Calendar className="h-6 w-6 text-blue-600" />}
              {activeTab === "completed" && <CheckCircle2 className="h-6 w-6 text-blue-600" />}
              {activeTab === "cancelled" && <X className="h-6 w-6 text-blue-600" />}
            </div>
            <h3 className="text-lg font-medium mb-2">No {activeTab} appointments</h3>
            <p className="text-gray-500 max-w-md mx-auto mb-6">
              {activeTab === "upcoming" 
                ? "You don't have any upcoming appointments scheduled. Book an appointment with one of our mentors."
                : activeTab === "cancelled" 
                ? "You don't have any cancelled appointments."
                : "You don't have any completed appointments yet."}
            </p>
            {activeTab === "upcoming" && (
              <Button 
                onClick={() => navigate('/patient-dashboard/find-mentor')}
                className="bg-blue-600 hover:bg-blue-700 text-white"
              >
                <CalendarPlus className="mr-2 h-4 w-4" />
                Book Appointment
              </Button>
            )}
          </div>
        ) : (
          <div className="space-y-4">
            {appointments
              .filter(appointment => {
                if (activeTab === "upcoming") {
                  return appointment.status === "pending" || appointment.status === "scheduled" || appointment.status === "confirmed";
                } else if (activeTab === "completed") {
                  return appointment.status === "completed";
                } else {
                  return appointment.status === "cancelled";
                }
              })
              .map((appointment) => (
                <Card key={appointment.id} className="overflow-hidden border border-gray-100 shadow-sm hover:shadow transition-shadow">
                  <CardContent className="p-0">
                    <div className="p-4 md:p-6">
                      <div className="flex flex-col md:flex-row md:items-center justify-between gap-4">
                        <div className="flex items-center space-x-4">
                          <Avatar className="h-12 w-12 border border-gray-100">
                            <AvatarImage src={appointment.mentor?.avatar} alt={appointment.mentor?.name || "Mentor"} />
                            <AvatarFallback className="bg-blue-100 text-blue-600">
                              {appointment.mentor?.name?.charAt(0) || "M"}
                            </AvatarFallback>
                          </Avatar>
                          <div>
                            <h3 className="font-medium text-gray-900">{appointment.mentor?.name || "Mood Mentor"}</h3>
                            <p className="text-sm text-gray-500">{appointment.mentor?.specialty || "Mental Health Support"}</p>
                            
                            <div className="flex items-center mt-1 gap-2">
                              <Badge 
                                className={`px-2 py-0.5 text-xs font-medium ${
                                  appointment.status === "pending" ? "bg-blue-100 text-blue-700" :
                                  appointment.status === "scheduled" ? "bg-green-100 text-green-700" :
                                  appointment.status === "completed" ? "bg-purple-100 text-purple-700" :
                                  "bg-red-100 text-red-700"
                                }`}
                              >
                                {appointment.status.charAt(0).toUpperCase() + appointment.status.slice(1)}
                              </Badge>
                              
                              <Badge variant="outline" className="px-2 py-0.5 text-xs font-medium bg-gray-50">
                                {appointment.type === "video" && <Video className="mr-1 h-3 w-3" />}
                                {appointment.type === "audio" && <Phone className="mr-1 h-3 w-3" />}
                                {appointment.type === "chat" && <MessageSquare className="mr-1 h-3 w-3" />}
                                {appointment.type.charAt(0).toUpperCase() + appointment.type.slice(1)}
                              </Badge>
                            </div>
                          </div>
                        </div>
                        
                        <div className="flex flex-col text-sm text-gray-500 md:text-right">
                          <div className="flex items-center md:justify-end">
                            <CalendarIcon className="h-4 w-4 mr-1.5 text-blue-500" />
                            <span>{appointment.date}</span>
                          </div>
                          <div className="flex items-center md:justify-end mt-1">
                            <Clock className="h-4 w-4 mr-1.5 text-blue-500" />
                            <span>{appointment.time}</span>
                          </div>
                        </div>
                      </div>
                      
                      <div className="mt-4 pt-4 border-t flex flex-wrap justify-end gap-2">
                        {appointment.status === "completed" && !appointment.isReviewed && (
                          <Button 
                            variant="outline" 
                            size="sm"
                            onClick={() => {
                              setSelectedAppointmentForReview({
                                id: appointment.id,
                                mentorId: appointment.mentor?.id || "",
                                mentorName: appointment.mentor?.name || "Mood Mentor"
                              });
                              setIsReviewModalOpen(true);
                            }}
                            className="text-blue-600 border-blue-200 hover:bg-blue-50"
                          >
                            <Star className="mr-1.5 h-4 w-4" />
                            Leave Review
                          </Button>
                        )}
                        
                        {(appointment.status === "pending" || appointment.status === "scheduled" || appointment.status === "confirmed") && (
                          <Button 
                            variant="outline" 
                            size="sm"
                            onClick={() => setCancelAppointmentId(appointment.id)}
                            className="text-red-600 border-red-200 hover:bg-red-50"
                          >
                            <X className="mr-1.5 h-4 w-4" />
                            Cancel
                          </Button>
                        )}
                        
                        {(appointment.status === "pending" || appointment.status === "scheduled" || appointment.status === "confirmed") && (
                          <Button 
                            variant="default" 
                            size="sm"
                            onClick={() => navigate(`/appointment/${appointment.id}`)}
                            className="bg-blue-600 hover:bg-blue-700 text-white"
                          >
                            {appointment.type === "video" && <Video className="mr-1.5 h-4 w-4" />}
                            {appointment.type === "audio" && <Phone className="mr-1.5 h-4 w-4" />}
                            {appointment.type === "chat" && <MessageSquare className="mr-1.5 h-4 w-4" />}
                            Join Session
                          </Button>
                        )}
                        
                        {appointment.status === "completed" && (
                          <Button 
                            variant="outline" 
                            size="sm"
                            onClick={() => navigate(`/appointment/${appointment.id}`)}
                            className="text-gray-600 border-gray-200 hover:bg-gray-50"
                          >
                            <FileText className="mr-1.5 h-4 w-4" />
                            View Summary
                          </Button>
                        )}
                        
                        {appointment.mentor && user?.id && (
                          <ChatButton 
                            userId={user.id}
                            targetUserId={appointment.mentor.id}
                            variant="outline"
                            size="sm"
                            className="text-blue-600 border-blue-200 hover:bg-blue-50"
                          />
                        )}
                      </div>
                    </div>
                  </CardContent>
                </Card>
              ))
            }
          </div>
        )}
        
        {/* Mood Mentors Section - Simple Design */}
        <div className="mt-10 pt-6 border-t border-gray-100" id="mood-mentors-section">
          <div className="flex justify-between items-center mb-6">
            <div>
              <h2 className="text-xl font-bold text-gray-800">Available Mentors</h2>
              <p className="text-gray-500">Book your next session with a specialist</p>
            </div>
            <Button 
              variant="outline" 
              onClick={() => navigate('/mood-mentors')}
              className="text-blue-600 border-blue-200 hover:bg-blue-50"
            >
              View All Mentors
            </Button>
          </div>
          
          {loadingMoodMentors ? (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              {[1, 2, 3].map((i) => (
                <Card key={i} className="border border-gray-100 shadow-sm">
                  <CardContent className="p-6">
                    <div className="flex items-center space-x-4">
                      <Skeleton className="h-12 w-12 rounded-full" />
                      <div className="space-y-2">
                        <Skeleton className="h-4 w-[180px]" />
                        <Skeleton className="h-4 w-[120px]" />
                      </div>
                    </div>
                    <div className="mt-4 space-y-2">
                      <Skeleton className="h-4 w-full" />
                      <Skeleton className="h-4 w-3/4" />
                    </div>
                    <div className="mt-4 flex gap-2">
                      <Skeleton className="h-9 w-full rounded-md" />
                      <Skeleton className="h-9 w-24 rounded-md" />
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          ) : moodMentors.length === 0 ? (
            <Card className="border border-gray-100 shadow-sm">
              <CardContent className="flex flex-col items-center justify-center py-12 text-center">
                <div className="bg-blue-100 rounded-full p-4 mb-4">
                  <GraduationCap className="h-8 w-8 text-blue-600" />
                </div>
                <h3 className="text-lg font-medium mb-2">No Mentors Available</h3>
                <p className="text-gray-500 max-w-md mb-6">
                  There are currently no mood mentors available for booking. Please check back later.
                </p>
              </CardContent>
            </Card>
          ) : (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
              {moodMentors.map((mentor) => (
                <Card key={mentor.id} className="border border-gray-100 shadow-sm hover:shadow transition-shadow">
                  <CardContent className="p-6">
                    <div className="flex items-center space-x-4 mb-4">
                      <Avatar className="h-12 w-12 border border-gray-100">
                        <AvatarImage src={mentor.avatar} alt={mentor.name} />
                        <AvatarFallback className="bg-blue-100 text-blue-600">
                          {mentor.name.charAt(0)}
                        </AvatarFallback>
                      </Avatar>
                      <div>
                        <h3 className="font-medium text-gray-900">{mentor.name}</h3>
                        <p className="text-sm text-gray-500">{mentor.specialty}</p>
                      </div>
                    </div>
                    
                    {mentor.rating && (
                      <div className="flex items-center mb-3">
                        <div className="flex mr-2">
                          {Array.from({ length: 5 }).map((_, i) => (
                            <Star
                              key={i}
                              className={`h-3.5 w-3.5 ${
                                i < Math.floor(mentor.rating || 0)
                                  ? "text-yellow-400 fill-yellow-400"
                                  : "text-gray-300"
                              }`}
                            />
                          ))}
                        </div>
                        <span className="text-xs text-gray-500">
                          {mentor.rating.toFixed(1)}
                          {mentor.reviews && mentor.reviews > 0 && ` (${mentor.reviews})`}
                        </span>
                      </div>
                    )}
                    
                    <p className="text-sm text-gray-600 line-clamp-2 mb-4">
                      {mentor.bio || `${mentor.name} is a mental health specialist with expertise in ${mentor.specialty}.`}
                    </p>
                    
                    <div className="flex gap-2">
                      <Button 
                        className="flex-1 bg-blue-600 hover:bg-blue-700 text-white"
                        onClick={() => handleBookWithMentor(mentor.id)}
                      >
                        Book Session
                      </Button>
                      <Button 
                        variant="outline" 
                        className="border-blue-200 text-blue-600 hover:bg-blue-50"
                        onClick={() => handleViewMentorProfile(mentor.id)}
                      >
                        Profile
                      </Button>
                    </div>
                  </CardContent>
                </Card>
              ))}
            </div>
          )}
        </div>
        
        {/* Cancel Appointment Dialog */}
        <Dialog open={!!cancelAppointmentId} onOpenChange={() => setCancelAppointmentId(null)}>
          <DialogContent className="sm:max-w-md">
            <DialogHeader>
              <DialogTitle>Cancel Appointment</DialogTitle>
              <DialogDescription>
                Are you sure you want to cancel this appointment? This action cannot be undone.
              </DialogDescription>
            </DialogHeader>
            <DialogFooter className="sm:justify-start">
                <Button 
                  variant="outline" 
                onClick={() => setCancelAppointmentId(null)}
                >
                No, Keep Appointment
                </Button>
              <Button 
                variant="destructive" 
                onClick={() => handleCancelAppointment(cancelAppointmentId!)}
                disabled={cancelingAppointment}
              >
                {cancelingAppointment ? "Cancelling..." : "Yes, Cancel Appointment"}
              </Button>
            </DialogFooter>
          </DialogContent>
        </Dialog>
        
        {/* Review Modal */}
        {selectedAppointmentForReview && (
          <ReviewModal
            isOpen={isReviewModalOpen}
            onClose={() => setIsReviewModalOpen(false)}
            appointmentId={selectedAppointmentForReview.id}
            mentorId={selectedAppointmentForReview.mentorId}
            mentorName={selectedAppointmentForReview.mentorName}
            onSubmitReview={() => {
              setIsReviewModalOpen(false);
              setSelectedAppointmentForReview(null);
              fetchAppointments();
              toast.success("Thank you for your review!");
            }}
          />
        )}
      </div>
    </DashboardLayout>
  );
}
}